---
title: SOS DP 讲义
tags: [OI]
categories: [转载]
date: 2025-3-8
description: 飞鹰队训练讲义，恶心人的玩意
articleGPT: 服务器繁忙，请稍后再试
---
## SOS DP 讲义翻译
# 介绍

在这篇文章中，我将分享我在使用动态规划解决涉及**子集和（Sum over Subsets, SOS）**计算问题方面的一些小知识。因此，这篇文章被称为**SOS DP**。我选择这个主题是因为它在比赛中经常出现，通常是中等难度及以上的问题，但很少有博客或社论解释其背后的有趣动态规划。我对此也有特别的偏好，因为我第一次接触到它是在2014年ICPC阿姆利则区域赛。从那时起，我在各种平台上创建了许多基于这个概念的问题，但被接受的解决方案数量似乎总是与概念的清晰度不成比例。以下是一个小小的尝试，旨在弥合这一差距。

# 问题

我将解决以下问题：给定一个固定的包含 $ 2^N $ 个整数的数组 $ A $，我们需要计算对于所有 $ x $ 的函数 $ F(x) = $ 所有满足 $ x\&i = i $ 的 $ A[i] $ 的和，即 $ i $ 是 $ x $ 的子集。

$$
F[maxk] = \sum_{i \subseteq mask} A[i]
$$

# 先决条件

- 基本动态规划
- 位掩码

这绝不应被视为对上述主题的介绍。

# 解决方案

## 暴力解法

```cpp
for(int mask = 0; mask < (1<<N); ++mask){
    for(int i = 0; i < (1<<N); ++i){
        if((mask&i) == i){
            F[mask] += A[i];
        }
    }
}
```

这个解决方案非常直接，但效率低下，时间复杂度为 $O(4^{N})$。

## 次优解法

```cpp
// 遍历所有掩码  
for (int mask = 0; mask < (1<<n); mask++) {
    F[mask] = A[0];
    // 遍历掩码的所有子集  
    for(int i = mask; i > 0; i = (i-1) & mask){
        F[mask] += A[i];
    }
}
```

这个解决方案不那么直接，但更高效，时间复杂度为 $O(3^{N})$。要计算这个算法的时间复杂度，注意到对于每个掩码，我们只遍历其子集。因此，如果一个掩码有 $K$ 个置位，我们进行 $2^{K}$ 次迭代。此外，具有 $K$ 个置位的掩码总数是 $\binom{N}{K}$。因此，总迭代次数为 $\sum_{k=0}^{N} \binom{N}{K} 2^{k} = (1 + 2)^{N} = 3^{N}$。

## SoS 动态规划解决方案

在这种方法中，我们将尝试以更聪明的方式遍历掩码的所有子集。我们之前方法的一个明显缺陷是，一个具有 $K$ 个未置位的索引 **AR** 会被 $2^{K}$ 个 **掩码** 访问。因此存在重复计算。 

这种开销的原因在于我们没有在不同 **F[mask]** 使用的 **A[x]** 之间建立任何关系。我们必须以某种方式为这些掩码添加另一个状态，并创建语义组以避免组的重复计算。

记 $ S(mask) = \{x|x \subseteq mask\} $。现在我们将这个集合划分为不相交的组。  
$ S(mask, i) = \{x|x \subseteq mask \& x \text{ mask } \oplus x < 2^{i+1}\} $，即仅包含那些与 **mask** 在前 i 位（从零开始）不同的 **mask** 子集。  
例如，$ S(1011010, 3) = \{1011010, 1010010, 1011000, 1010000\} $。使用这种方法，我们可以将任何集合表示为一些不相交集合的并集。

让我们尝试关联这些数字集合。S(mask, i) 包含所有与 **mask** 仅在前 i 位不同的子集。  
考虑如果 **mask** 的第 i 位为 0。在这种情况下，没有子集可以在第 i 位与 **mask** 不同，因为这意味着这些数字在第 i 位为 1，而 **mask** 在第 i 位为 0，这意味着它不是 **mask** 的子集。因此，这个集合中的数字现在只能在前 i-1 位不同。$\implies$ S(mask, i) = S(mask, i-1)。  
考虑如果 **mask** 的第 i 位为 1。现在属于 S(mask, i) 的数字可以分为两个不相交的集合。一个包含第 i 位为 1 且在前 i-1 位与 **mask** 不同的数字。另一个包含第 i 位为 0 且在前 i-1 位与 **mask** $\oplus 2^i$ 不同的数字。$\implies$ S(mask, i) = S(mask, i-1) $\cup$ S(mask$\oplus 2^i$, i-1)。

$$
S(mask, i) = 
\begin{cases} 
S(mask, i - 1) & \text{第 i 位为 OFF}\\
S(mask, i - 1) \cup S(mask \oplus 2^i, i - 1) & \text{第 i 位为 ON}
\end{cases}
$$

下图描述了如何将 **S(mask,i)** 集合相互关联。任何集合 **S(mask,i)** 的元素都是其子树中的**叶子**。红色前缀表示掩码的这一部分对其所有成员/子节点是共同的，而掩码的黑色部分可以不同。
![](https://cdn.luogu.com.cn/upload/image_hosting/s10h2514.png)

请注意，这些关系形成了一个有向无环图（DAG），而不一定是一个有根树（考虑不同的 **mask** 值和相同的 **i** 值）。  
在认识到这些关系后，我们可以很容易地提出相应的动态规划解决方案。

### 迭代版本

```cpp
for(int mask = 0; mask < (1<<N); ++mask){  
    dp[mask][-1] = A[mask]; // 单独处理基本情况（叶子状态）  
    for(int i = 0; i < N; ++i){  
        if(mask & (1<<i))  
            dp[mask][i] = dp[mask][i-1] + dp[mask^(1<<i)][i-1];  
        else  
            dp[mask][i] = dp[mask][i-1];  
    }  
    F[mask] = dp[mask][N-1];  
}  
```

### 内存优化版本，编码非常简单

```cpp
for(int i = 0; i < (1<<N); ++i)  
    F[i] = A[i];  
for(int i = 0; i < N; ++i) for(int mask = 0; mask < (1<<N); ++mask){  
    if(mask & (1<<i))  
        F[mask] += F[mask^(1<<i)];  
}  
```

上述算法的时间复杂度为 \(O(N^2)\)。
